<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-T9LBVECNMJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-T9LBVECNMJ',{anonymize_ip:!1})}</script><meta name=author content="lumostone"><title>當以太幣質押挖礦機遇見 Kubernetes－架設教學 ｜ lumostone</title><meta name=description content="為什麼使用 Kubernetes 作 staking？ 作為 staker，我們常擔憂 validator 是否會突然停機，或是被區塊鏈上其他節點認作是壞成員而遭到驅逐（slashing）"><link rel="shortcut icon" href=https://lumostone.com/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://lumostone.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://lumostone.com/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=/zh-tw><span>lumostone</span></a></h1></div><div class=description><p class=sub_title></p><div class=my_socials><a href=https://github.com/lumostone title=github target=_blank><i class=ri-github-fill></i></a></div></div></div></div><div class=content><div class=post_page><section class=translations><span>這篇文章有以下語言版本：</span><ul><li><a href=/en/eth2-staking-with-k8s-prysm/>English</a></li></ul></section><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><a href=/zh-tw/eth2-staking-with-k8s-prysm/><h2>當以太幣質押挖礦機遇見 Kubernetes－架設教學</h2></a></div><section class=post_meta><div class=meta><div class=info><span class=field><i class=ri-map-pin-time-line></i>
<span class=date>2021.04.19</span></span>
<span class="field tags"><i class=ri-stack-line></i>
<a href=/zh-tw/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/>以太坊</a>
<a href=/zh-tw/tags/kubernetes/>kubernetes</a>
<a href=/zh-tw/tags/%E6%95%99%E5%AD%B8/>教學</a></span></div></div></section><div class="post_content markdown"><h2 id=為什麼使用-kubernetes-作-staking>為什麼使用 Kubernetes 作 staking？</h2><p>作為 staker，我們常擔憂 validator 是否會突然停機，或是被區塊鏈上其他節點認作是壞成員而遭到驅逐（slashing）。如何最小化停機時間和降低被驅逐的風險，成為了一個 staker 時常考慮的問題。</p><p>停機的原因百百種，可能是系統需要執行更新，軟體有問題，網路斷線，硬碟罷工等等。我們都希望可以時時監控，一旦有問題發生就立刻處理，但問題可大可小，不是每一次都能很快修復，除非是全職 staking，不然一般也沒辦法二十四小時監控處理。面對這種有高可用性的需求情境時，我們很自然地會想到 redundancy，如果怕一台機器停工，那我就再多準備幾台機器，一旦有問題就可以把系統轉移到健康的機器。</p><p>然而，我們常在論壇上看到 staker 們彼此警告「redundancy 可能會導致 slashing」，因為在轉移系統的過程，可能會因為手動操作疏失，不小心讓多個 validator 用戶端同時使用同一個 validator 金鑰，或是 slashing protection database 移轉時資料毀損，新的 validator 太快上線，又重新上傳了已經驗證過的區塊等等，這些都會讓 validator 面臨 slashing 的懲罰。當我們有多個 validator ，又同時想要追求 redundancy、高可用性，這些維運複雜度就會跟著上升，追求 redundancy 反而產生更多 slashing 的風險。</p><p><strong>我們有可能降低 slashing 風險跟維運複雜度，同時又能擁抱 redundancy 帶給我們的好處嗎？</strong> 有的！我們認為 <a href=https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/>Kubernetes</a> 可以幫我們做到這件事，運用 Kubernetes 管理 validator 的生命週期，自動化容錯移轉（failover），在軟體更新時，只需要更改版本號，Kubernetes 就可以幫我們安全升級，今天硬體要更新，要手動移轉 validator 時，僅用一個指令便能完成（例如：<code>kubectl drain node</code>）。</p><p>我們希望這篇教學文章可以作為以太坊 2.0 staker community 的墊腳石，讓 stakers 可以利用 Kubernetes 建立一個有擴充性又有 redundancy 的基礎架構，一起輕鬆 staking！</p><h2 id=感謝>感謝</h2><p>謝謝以太坊基金會以 <a href=https://blog.ethereum.org/2021/02/09/esp-staking-community-grantee-announcement/>Eth2 Staking Community Grants</a> 支持這個專案，能夠對 staker community 貢獻是我們的榮幸！</p><h2 id=使用工具>使用工具</h2><p>這份教學將示範如何在一個 Kubernetes 叢集上維運一個以太坊 2.0 beacon 用戶端和多個 validator 用戶端， 以下是我們使用的工具：</p><ul><li><a href=https://github.com/prysmaticlabs/prysm>Prysm</a> 以太坊 2.0 用戶端</li><li><a href=https://microk8s.io/>MicroK8s</a> 輕量的 Kubernertes 發行版（<a href=https://microk8s.io/docs>安裝教學</a>）</li><li><a href=https://helm.sh/>Helm 3</a> Kubernetes 套件管理工具</li><li><a href=https://kubernetes.io/docs/reference/kubectl/overview/>kubectl</a> Kubernetes CLI 工具</li><li>Ubuntu Server 20.04.2 LTS (x64) （<a href=https://ubuntu.com/download/server>下載連結</a>）</li><li><a href=https://en.wikipedia.org/wiki/Network_File_System>Network File System (NFS)</a> 作為 beacon 與 validator 用戶端的持久性儲存系統（<a href=https://ubuntu.com/server/docs/service-nfs>Ubuntu 文件與教學</a>）</li><li><a href=https://github.com/lumostone/eth2xk8s>eth2xk8s</a> Helm Chart</li></ul><h2 id=本文目標>本文目標</h2><p>這份教學包含以下內容：</p><ul><li>使用 MicroK8s 建立一個 Kubernetes 叢集。如果你有已建好的 Kubernetes 叢集，或想使用其他的 Kubernetes 發行版，可以在建好叢集後跳至「<a href=#%E5%AE%89%E8%A3%9D%E5%92%8C%E8%A8%AD%E5%AE%9A-nfs>安裝和設定NFS</a>」章節。如果你是使用雲端服務提供商所提供的 Kubernetes 托管服務（例如 AKS, EKS, GKE 等），你可以考慮直接使用雲端存儲服務（例如 Azure Disk, AWS S3 等）作為 beacon 與 validator 用戶端的持久性儲存系統，而非使用 NFS。我們未來會撰寫其他文章討論這個部分。</li><li>安裝和設定 NFS。</li><li>準備用以安裝 Prysm 以太坊 2.0 用戶端的 Helm Chart。</li><li>使用 Helm Chart 安裝 Prysm 以太坊 2.0 用戶端。</li><li>確認用戶端狀態。</li><li>使用 Helm Chart 升級和回溯 Prysm 以太坊 2.0 用戶端。</li></ul><h2 id=非本文目標>非本文目標</h2><p>這份教學<strong>不包含</strong>：</p><ul><li>如何調校系統或軟體表現及資源用量。</li><li>如何存入 validator 押金並產生 validator 金鑰。</li><li>如何設定高可用性的 Kubernetes 叢集。</li><li>如何強化 Kubernetes 叢集安全性。</li></ul><h2 id=免責聲明>免責聲明</h2><p>這份教學的設置目前僅在以太坊測試網路上開發和測試。</p><p>做質押挖礦（staking）的礦工要承擔相應的風險，我們強烈建議，在正式網路（mainnet）staking 前，都先在測試網路上試跑，藉此熟悉所有可能的維運操作，並透過系統在測試網路上的表現調整硬體配備，強化系統安全。這份教學僅作為使用 Kubernetes 作 staking 的設置參考，<strong>對於因遵循本指南而造成的任何財務損失，作者概不負責。</strong></p><h2 id=系統需求>系統需求</h2><p>我們需要至少三台機器（虛擬機或實體機皆可）來完成這份教學的設置。一台機器會作為 NFS 伺服器來儲存 staking 資料；第二台機器作為 Kubernetes 叢集裡的「主要」（master）節點，用來運行 Kubernetes 的核心元件；第三台機器則是 Kubernetes 叢集裡的 「工作」（worker）節點用以執行 beacon 及 validator 用戶端。若要作高可用性配置，請參考 <a href=https://microk8s.io/docs/high-availability>MicroK8s 高可用性設定文件</a>來新增更多的節點，並定期備份 beacon 資料，這樣在資料毀損重建時，也可以較快完成同步再次上線。我們將會在往後的文章裡討論高可用性的設置。</p><p>基於在 <a href=https://prater.beaconcha.in/><strong>Prater 測試網路</strong></a>上的試跑結果以及 <a href=https://microk8s.io/docs>MicroK8s 官方文件</a>，以下是我們建議的最小系統需求。請注意，<strong>最小系統需求並不保證最佳的系統表現及成本效益。</strong></p><p>Master 主要節點：</p><ul><li>RAM: 至少 8 GB</li><li>CPU: 至少 1 core</li><li>Disk: 至少 20 GB</li></ul><p>Worker 工作節點：</p><ul><li>RAM: 至少 8 GB</li><li>CPU: 至少 1 core</li><li>Disk: 至少 20 GB</li></ul><p>NFS：</p><ul><li>RAM: 至少 2 GB</li><li>CPU: 至少 1 core</li><li>Disk: 至少 250 GB（再次提醒，這個規格是基於測試網路的用量，如果在正式網路執行，可能需準備更多的儲存空間。）</li></ul><h2 id=網路需求>網路需求</h2><ul><li>所有機器皆有網際網路連線能力（至少在安裝過程中）。</li><li>主要節點和工作節點網路可以互通。我們在後續的章節會設定 MicroK8s 所需要的防火牆規則，更多細節可參考 <a href=https://microk8s.io/docs/ports>MicroK8s 官方文件</a>。</li><li>主要節點和工作節點皆可連至 NFS 伺服器。</li><li>主要節點和工作節點皆可連至為質押挖礦所準備的以太坊 1.0 “Goerli” 節點（請參考「<a href=#%E4%BA%8B%E5%89%8D%E6%BA%96%E5%82%99>事前準備</a>」章節）。</li></ul><h2 id=事前準備>事前準備</h2><ul><li>已為 validator 存入足夠的押金，並已產生 validator 金鑰。如果需要參考步驟，我們推薦 <a href=https://someresat.medium.com/guide-to-staking-on-ethereum-2-0-ubuntu-pyrmont-prysm-a10b5129c7e3>Somer Esat 的教學文章</a>。</li><li>已擁有一個以太坊 1.0 測試網路 Goerli 的節點：<a href=https://someresat.medium.com/guide-to-staking-on-ethereum-2-0-ubuntu-pyrmont-prysm-a10b5129c7e3>Somer Esat 的教學文章</a>也包含了如何架設以太坊 1.0 的測試網路節點，你也可以選擇使用第三方的服務如 <a href=https://infura.io/>Infura</a> 或 <a href=https://alchemyapi.io/>Alchemy</a>。</li><li>規劃好內網，設定好防火牆跟轉發通訊埠。在「<a href=#%E8%A8%AD%E5%AE%9A%E6%AD%A5%E9%A9%9F>設定步驟</a>」章節會提到我們使用的網路設定。</li><li>已在三台機器安裝 Ubuntu Server 20.04.2 LTS (x64) ，並已指派靜態 IP 位址。</li></ul><h2 id=設定步驟>設定步驟</h2><h3 id=概要>概要</h3><p>在這篇教學裡，我們會建立一個 NFS 伺服器，一個 Kubernetes 叢集，並在叢集上安裝以太坊 2.0 beacon 節點及 validator 用戶端。我們將所有的機器放在同一個內網，並指派靜態 IP 位址給每一個機器，以下是我們的網路設定：</p><p><strong>私有內網網段: 172.20.0.0/20 (172.20.0.1 - 172.20.15.254)</strong></p><ul><li>NFS IP: 172.20.10.10</li><li>主要節點 IP: 172.20.10.11</li><li>工作節點 IP: 172.20.10.12</li><li>DNS: 8.8.8.8, 8.8.4.4 (Google’s DNS)</li></ul><h3 id=安裝系統更新>安裝系統更新</h3><p>請在每一台機器上執行以下命令：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt update <span style=color:#f92672>&amp;&amp;</span> sudo apt upgrade
sudo apt dist-upgrade <span style=color:#f92672>&amp;&amp;</span> sudo apt autoremove
sudo reboot
</code></pre></div><h3 id=同步系統時間>同步系統時間</h3><p>請在每一台機器上執行以下命令：</p><ol><li><p>設定時區，在此以<code>America/Los_Angeles</code>為例：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>timedatectl list-timezones
sudo timedatectl set-timezone America/Los_Angeles
</code></pre></div></li><li><p>確認預設的 timekeeping service (NTP service) 有啟動</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>timedatectl
</code></pre></div></li><li><p>安裝<code>chrony</code></p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt install chrony
</code></pre></div></li><li><p>編輯<code>chrony</code>設定</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo nano /etc/chrony/chrony.conf
</code></pre></div><p>加入以下服務器池：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pool time.google.com     iburst minpoll <span style=color:#ae81ff>1</span> maxpoll <span style=color:#ae81ff>2</span> maxsources <span style=color:#ae81ff>3</span>
pool us.pool.ntp.org     iburst minpoll <span style=color:#ae81ff>1</span> maxpoll <span style=color:#ae81ff>2</span> maxsources <span style=color:#ae81ff>3</span>
pool ntp.ubuntu.com      iburst minpoll <span style=color:#ae81ff>1</span> maxpoll <span style=color:#ae81ff>2</span> maxsources <span style=color:#ae81ff>3</span>
</code></pre></div><p>更改這兩個設定：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>maxupdateskew 5.0 <span style=color:#75715e># The threshold for determining whether an estimate is too unreliable to be used.</span>
makestep 0.1 -1  <span style=color:#75715e># This would step the system clock if the adjustment is larger than 0.1 seconds.</span>
</code></pre></div></li><li><p>重新啟動<code>chrony</code>服務</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo systemctl restart chronyd
</code></pre></div></li><li><p>確認<code>chrony</code>使用的同步資料來源</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chronyc sources
</code></pre></div><p>確認<code>chrony</code>的狀態</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chronyc tracking
</code></pre></div></li></ol><h3 id=設定防火牆>設定防火牆</h3><p>請在所有機器上執行步驟一至步驟三：</p><ol><li><p>設定預設防火牆規則</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw default deny incoming
sudo ufw default allow outgoing
</code></pre></div></li><li><p>（<strong>建議</strong>）將<code>ssh</code>通訊埠從<code>22</code>換成其他通訊埠號以強化安全性。透過編輯<code>sshd_config</code>設定檔，將<code>Port 22</code>改成其他通訊埠號：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo nano /etc/ssh/sshd_config
</code></pre></div><p>重新啟動<code>ssh</code>服務</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo service sshd restart
</code></pre></div></li><li><p>允許 TCP 連線透過<code>ssh</code>所使用的通訊埠進入</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw allow &lt;ssh-port&gt;/tcp
</code></pre></div></li><li><p>在 NFS 伺服器上加入 NFS 服務所需的防火牆規則：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw allow 2049/tcp
</code></pre></div></li><li><p>在主要節點與工作節點的機器上，加入 MicroK8s 所需的防火牆規則：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw allow 16443/tcp
sudo ufw allow 10250/tcp
sudo ufw allow 10255/tcp
sudo ufw allow 25000/tcp
sudo ufw allow 12379/tcp
sudo ufw allow 10257/tcp
sudo ufw allow 10259/tcp
sudo ufw allow 19001/tcp
</code></pre></div></li><li><p>在主要節點與工作節點的機器上，加入 beacon 節點所需的防火牆規則：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw allow 12000/udp
sudo ufw allow 13000/tcp
</code></pre></div></li><li><p>最後，在每一台機器上啟動防火牆服務</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ufw <span style=color:#111>enable</span>
sudo ufw status numbered
</code></pre></div></li></ol><h3 id=安裝-microk8s>安裝 MicroK8s</h3><p>你可以直接參考 <a href=https://microk8s.io/docs>MicroK8s 官方文件</a>，或參考以下步驟來完成安裝與設定。</p><p>請在主要節點及工作節點上執行以下命令：</p><ol><li><p>安裝並執行 MicroK8s</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo snap install microk8s --classic --channel<span style=color:#f92672>=</span>1.20/stable
</code></pre></div></li><li><p>授予非管理員使用者（non-root user）管理 MicroK8s 的權限。將該使用者加入 MicroK8s 的群組中，並改變<code>~/.kube</code> 目錄的所有權：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo usermod -a -G microk8s <span style=color:#111>$USER</span>
sudo chown -f -R <span style=color:#111>$USER</span> ~/.kube

su - <span style=color:#111>$USER</span> <span style=color:#75715e># 重新進入該使用者的session來讓改變生效</span>
</code></pre></div></li><li><p>等待 MicroK8s 就緒</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s status --wait-ready
</code></pre></div></li><li><p>確認所有的節點已就緒</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl get node
</code></pre></div><p>在輸出的節點清單上，你應只會看到一個節點。</p></li></ol><h3 id=建立叢集>建立叢集</h3><p>在建立叢集前，請確認 MicroK8s 已成功在主要節點及工作節點上執行。</p><p>在主要節點上執行以下步驟：</p><ol><li><p>啟動 DNS 和 Helm 3 功能</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s <span style=color:#111>enable</span> dns helm3
</code></pre></div></li><li><p>使用<code>add-node</code>命令產生連接字串，用以讓工作節點加入叢集</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s add-node
</code></pre></div><p>你會看到類似以下輸出結果：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>Join node with:
microk8s join 172.31.20.243:25000/DDOkUupkmaBezNnMheTBqFYHLWINGDbf

If the node you are adding is not reachable through the default
interface you can use one of the following:

microk8s join 172.31.20.243:25000/DDOkUupkmaBezNnMheTBqFYHLWINGDbf
microk8s join 10.1.84.0:25000/DDOkUupkmaBezNnMheTBqFYHLWINGDbf
</code></pre></div></li></ol><p>轉換到工作節點，執行以下步驟：</p><ol><li><p>執行剛剛在主要節點產生的<code>join</code>命令，例如：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s join 172.31.20.243:25000/DDOkUupkmaBezNnMheTBqFYHLWINGDbf
</code></pre></div></li><li><p>工作節點成功加入叢集後，請執行以下命令確認兩個節點已準備就緒</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl get node
</code></pre></div></li></ol><h3 id=安裝和設定-nfs>安裝和設定 NFS</h3><p>你可以直接參考 <a href=https://ubuntu.com/server/docs/service-nfs>Ubuntu 官方文件</a>，或參考以下步驟來完成安裝與設定：</p><p>在預計執行 NFS 的機器上：</p><ol><li><p>安裝並啟動 NFS 伺服器</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt install nfs-kernel-server
sudo systemctl start nfs-kernel-server.service
</code></pre></div></li><li><p>為 beacon、validator 用戶端及錢包建資料目錄</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo mkdir -p /data/prysm/beacon

sudo mkdir -p /data/prysm/validator-client-1 /data/prysm/wallet-1
sudo mkdir -p /data/prysm/validator-client-2 /data/prysm/wallet-2
</code></pre></div><p><strong>請注意每一個錢包只能讓一個 validator 用戶端使用。</strong> 你可以匯入多個 validator 金鑰到同一個錢包，並讓一個 validator 用戶端來為多個 validators 提交區塊驗證結果。</p><p><strong>為避免 slashing，請不要讓多個 validator 用戶端使用同一個錢包，或將同一把 validator 金鑰匯入多個有 validator 使用的錢包。</strong></p></li><li><p>設定並匯出 NFS 儲存空間</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo nano /etc/exports
</code></pre></div><p>加入以下的設定並存檔：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/data *<span style=color:#f92672>(</span>rw,sync,no_subtree_check<span style=color:#f92672>)</span>
</code></pre></div><p>設定選項敘述：</p><ul><li><strong>*</strong>: hostname 格式</li><li><strong>rw</strong>: 讀寫權限</li><li><strong>sync</strong>: 在回覆更動要求前，所有的改變都保證會被寫入儲存空間</li><li><strong>no_subtree_check</strong>: 如果設定中包含 no_subtree_check 這個值，之後將不會檢查 subtree。雖然這個設定可能帶來一些安全疑慮，但在某些狀況下，穩定性會因此提升。因為 subtree_checking 比起 no_subtree_check 會造成更多問題，在 nfs-utils 版本 1.1.0 及往後版本，預設值都是 no_subtree_check。</li></ul><p>可以參照 <a href=https://man7.org/linux/man-pages/man5/exports.5.html>NFS 伺服器匯出表手冊</a>了解其他細節。</p><p>匯出設定</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo exportfs -a
</code></pre></div></li><li><p>在主要節點及工作節點上安裝<code>nfs-common</code>以支援 NFS：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt install nfs-common
</code></pre></div></li></ol><h3 id=準備-validator-錢包>準備 Validator 錢包</h3><p>你可以直接參考 <a href=https://docs.prylabs.network/docs/mainnet/joining-eth2/#step-4-import-your-validator-accounts-into-prysm>Prysm 官方文件</a>，或參考以下步驟來完成錢包設定：</p><p>在設定錢包前，請先確認 validator 金鑰已經傳到 NFS 伺服器上。這一個章節我們要來用上一章裡建好的錢包目錄來建立錢包並匯入 validator 金鑰。</p><p>我們使用 Prysm 提供的腳本來完成設定：</p><ol><li><p>請參考 <a href=https://docs.prylabs.network/docs/install/install-with-script/#downloading-the-prysm-startup-script>Prysm 官方文件</a>下載設定腳本（Prysm startup script）</p></li><li><p>執行腳本時要提供金鑰所在的目錄路徑到<code>--keys-dir=&lt;path/to/validator-keys></code>參數。我們的範例裡使用<code>$HOME/eth2.0-deposit-cli/validator_keys</code>當作金鑰目錄</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo ./prysm.sh validator accounts import --keys-dir<span style=color:#f92672>=</span><span style=color:#111>$HOME</span>/eth2.0-deposit-cli/validator_keys
</code></pre></div></li><li><p>接著輸入錢包目錄路徑，例如<code>/data/prysm/wallet-1</code></p></li><li><p>輸入錢包密碼（<strong>記得備份在一個安全的地方！</strong>)</p></li><li><p>接著輸入 validator 金鑰的密碼（使用 <a href=https://github.com/ethereum/eth2.0-deposit-cli>eth2.0-deposit-cli</a> 產生 validator 金鑰時所建立的那組密碼）。如果輸入正確，即可成功匯入 validator 帳號至錢包裡。</p></li></ol><h3 id=改變資料目錄擁有者>改變資料目錄擁有者</h3><p>為了讓 Kubernetes 能夠替 beacon 及 validator 用戶端正確地掛載儲存空間，我們必須改變 NFS 上的資料目錄 owner：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo chown -R 1001:2000 /data <span style=color:#75715e># you can pick other user ID and group ID</span>
</code></pre></div><h3 id=準備-helm-chart>準備 Helm Chart</h3><p>我們知道要從零開始學習 Kubernetes 以及寫出建立資源的 YAML 文件不是一件簡單的事，所以我們開發了可用來建立 beacon 和 validator 用戶端的 YAML 檔和 Helm Chart，並上傳到 <a href=https://github.com/lumostone/eth2xk8s>eth2xk8s</a> Github repository 來供大家使用。希望能幫助大家更容易上手！</p><p>在這篇教學裡，我們用 Helm 來安裝與升級 beacon 及 validator 用戶端。你也可以不使用 Helm 直接使用 YAML 檔來建立 Kubernetes 資源。細節可以看這兩篇文章：「<a href=https://github.com/lumostone/eth2xk8s/blob/master/testing-with-host-path.md>使用 Kubernetes manifests 以及 hostPath 測試以太坊 2.0 Staking</a> 」以及「<a href=https://github.com/lumostone/eth2xk8s/blob/master/testing-with-nfs.md>使用 Kubernetes manifests 以及 NFS 測試以太坊 2.0 Staking</a>」。</p><ol><li><p>Clone <a href=https://github.com/lumostone/eth2xk8s>eth2xk8s</a> Github 專案</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git clone https://github.com/lumostone/eth2xk8s.git
</code></pre></div></li><li><p>更改 <a href=https://github.com/lumostone/eth2xk8s/blob/master/prysm/helm/values.yaml>prysm/helm/values.yaml</a> 的值</p><p>建議閱讀<code>values.yaml</code>的每個變數及說明，確認是否更改預設值。以下列出安裝 Helm Chart 前必須更改的變數：</p><ul><li><strong>nfs.serverIp</strong>: NFS 伺服器 IP 地址</li><li><strong>nfs.user</strong>: 容器（container）裡的每個程序（process）會使用這個 user ID 來執行。這個使用者需擁有存取掛載的 NFS 資料目錄路徑的權限。</li><li><strong>nfs.group</strong>: 容器裡的每個程序會使用這個 group ID 來執行。這個群組需擁有存取掛載的 NFS 資料目錄路徑的權限。我們用此來給予程序有限的權限，不然預設 Kubernetes 會使用 root 群組執行程序。</li><li><strong>image.version</strong>: Prysm 用戶端版本</li><li><strong>beacon.dataVolumePath</strong>: NFS 上的 beacon 資料目錄路徑</li><li><strong>beacon.web3Provider</strong> 及 <strong>beacon.fallbackWeb3Providers</strong>: 以太坊 1.0 節點網址</li><li><strong>validatorClients.validatorClient1.dataVolumePath</strong>: NFS 上的 validator 用戶端資料目錄路徑</li><li><strong>validatorClients.validatorClient1.walletVolumePath</strong>: NFS 上的錢包資料目錄路徑</li><li><strong>validatorClients.validatorClient1.walletPassword</strong>: 錢包密碼</li></ul></li></ol><h3 id=使用-helm-chart-安裝-prysm>使用 Helm Chart 安裝 Prysm</h3><p>Kubernetes 使用 <a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>namespaces</a> 來作命名及資源區隔及存取限制。我們使用<code>prysm</code>當作 Prysm 用戶端的 namespace。</p><p>Helm 使用 <a href=https://helm.sh/docs/glossary/#release>releases</a> 來追蹤 chart 的安裝紀錄。在這篇教學裡，我們用<code>eth2xk8s</code>當作我們的 release 名字，你也可以改成其他你想要的名字。</p><p>在主要節點上：</p><ol><li><p>創造一個 namespace</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl create namespace prysm
</code></pre></div></li><li><p>安裝 Prysm 用戶端</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 install eth2xk8s ./prysm/helm -nprysm
</code></pre></div></li><li><p>檢查部署設定</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 get manifest eth2xk8s -nprysm
</code></pre></div></li></ol><h3 id=檢查用戶端狀態>檢查用戶端狀態</h3><ol><li><p>檢查部署狀態</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl get pod -nprysm -w
</code></pre></div><p>這個指令會持續監控狀態變化，我們只需等到 beacon 及 validator 用戶端都變成 Running 狀態即可。</p></li><li><p>檢查 beacon 的執行記錄</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl logs -f -nprysm -l <span style=color:#111>app</span><span style=color:#f92672>=</span>beacon
</code></pre></div></li><li><p>檢查 validator 用戶端的執行記錄</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl logs -f -nprysm -l <span style=color:#111>app</span><span style=color:#f92672>=</span>validator-client-1
</code></pre></div><p>如果想檢查其他的 validator用戶端，可以將<code>-l app=&lt;validator client name></code>更改成在<code>values.yaml</code>設定的其他 validator 用戶端的名字，以 validator-client-2 為例</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl logs -f -nprysm -l <span style=color:#111>app</span><span style=color:#f92672>=</span>validator-client-2
</code></pre></div></li></ol><h3 id=使用-helm-chart-更新-prysm-版本>使用 Helm Chart 更新 Prysm 版本</h3><p>以太坊 2.0 用戶端的新版本推出速度很快，我們應該盡快更新用戶端版本來獲得最新的 bug fixes 和功能。為了簡化版本跟軟體部署的管理，我們推薦用 Helm 來更新版本：</p><ol><li><p>到 <a href=https://github.com/prysmaticlabs/prysm/releases>Prysm Github 版本釋出頁面</a>查看最新版本</p></li><li><p>將<code>values.yaml</code>中的 <strong>image.version</strong> 改成最新版本（例如 <code>v1.3.4</code>）並儲存<code>values.yaml</code></p></li><li><p>執行以下 Helm 指令更新用戶端</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 upgrade eth2xk8s ./prysm/helm -nprysm
</code></pre></div></li><li><p>檢查部署設定，確認用戶端已更新成新版本</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 get manifest eth2xk8s -nprysm
</code></pre></div></li><li><p>依照「<a href=#%E6%AA%A2%E6%9F%A5%E7%94%A8%E6%88%B6%E7%AB%AF%E7%8B%80%E6%85%8B>檢查用戶端狀態</a>」章節檢查用戶端是否正常執行</p></li></ol><h3 id=使用-helm-回溯版本>使用 Helm 回溯版本</h3><p>如果版本回溯不牽涉資料庫 schema 變動的話，使用 Helm 回溯版本就跟更新一樣直覺。以下是範例步驟及指令：</p><ol><li><p>使用<code>helm history</code>指令找出並記下想要回溯到的版本號碼</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 <span style=color:#111>history</span> eth2xk8s -nprysm
</code></pre></div></li><li><p>回溯到指定版本（以下指令假設我們要回溯到版本 4）</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 rollback eth2xk8s <span style=color:#ae81ff>4</span> -nprysm
</code></pre></div></li><li><p>接著依照「<a href=#%E6%AA%A2%E6%9F%A5%E7%94%A8%E6%88%B6%E7%AB%AF%E7%8B%80%E6%85%8B>檢查用戶端狀態</a>」章節檢查部署設定以及用戶端是否正常執行。</p></li></ol><p>如果版本回溯前需要先還原資料庫 schema，可以參照「<a href=#%E4%BD%BF%E7%94%A8-helm-%E5%9B%9E%E6%BA%AF%E7%89%88%E6%9C%AC%E5%A6%82%E6%9E%9C%E8%B3%87%E6%96%99%E5%BA%AB-schema-%E6%9C%89%E6%9B%B4%E5%8B%95>使用 Helm 回溯版本（如果資料庫 Schema 有更動)</a>」章節。</p><p>某些情況下有可能沒辦法回溯到之前的版本（<a href=https://docs.prylabs.network/docs/prysm-usage/staying-up-to-date/#downgrading-between-major-version-bumps>例子</a>），在回溯前記得先確認用戶端相關文件。</p><h2 id=結論>結論</h2><p>感謝你的閱讀！我們希望這篇文章能夠幫助想要使用 Kubernetes 來做以太坊 2.0 staking 的你。我們會繼續製作相關教學，之後我們也會開發給其他以太坊 2.0 用戶端的 Helm Chart。敬請期待！</p><h2 id=有任何建議或是疑問嗎>有任何建議或是疑問嗎？</h2><p>請讓我們知道你的想法！如果對這篇文章有任何問題及建議都歡迎到我們<a href=https://github.com/lumostone/lumostone.github.io>網站的 Github 專案</a>開 issue 或是發 pull request。如果你對於貢獻以太坊 2.0 Staking 的 Helm Chart 有興趣，請將 issue 或 pull request 發至 <a href=https://github.com/lumostone/eth2xk8s>eth2xk8s</a> 跟我們聯繫。</p><h2 id=附錄>附錄</h2><h3 id=檢查-cpu-及記憶體用量>檢查 CPU 及記憶體用量</h3><p>如果想知道每個 pod 的 CPU 及記憶體用量，可以使用 Github 開源專案 <a href=https://github.com/kubernetes-sigs/metrics-server>metrics server</a> 來取得資料。</p><ol><li><p>首先，用以下的指令在 Kubernetes 叢集上安裝 metrics server</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
</code></pre></div></li><li><p>接著可以執行<code>kubectl top</code>指令來得到用量資訊，下面兩個例子分別會得到 beacon 及 validator 用戶端的用量。</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl top pod -l <span style=color:#111>app</span><span style=color:#f92672>=</span>beacon
microk8s kubectl top pod -l <span style=color:#111>app</span><span style=color:#f92672>=</span>validator-client-1
</code></pre></div></li></ol><h3 id=解除安裝-helm-chart>解除安裝 Helm Chart</h3><p>如果想要停止執行以及移除 Prysm，可以執行以下指令來移除整個 Helm Chart：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 uninstall eth2xk8s -nprysm
</code></pre></div><h3 id=使用-helm-回溯版本如果資料庫-schema-有更動>使用 Helm 回溯版本（如果資料庫 Schema 有更動）</h3><p>以 <a href=https://github.com/prysmaticlabs/prysm/releases/tag/v1.3.0>Prysm v1.3.0 版本</a>為例，如果想要回溯至 v1.2.x，我們需要在回溯前先跑一個腳本來還原 v1.3.0 帶來的資料庫 schema 變動。所以如果我們照著「<a href=#%E4%BD%BF%E7%94%A8-helm-%E5%9B%9E%E6%BA%AF%E7%89%88%E6%9C%AC>使用 Helm 回溯版本</a>」的步驟執行指令，在用 Helm 改變 Prsym 版本成 v1.2.2 之後，所有的 pods 會馬上重啟，但 Prysm 可能會因為資料庫 schema 只適用於 v1.3.0 版本而無法正常啟動。</p><p>要解決這個問題，我們可以利用 Kubernetes 暫時把 pod 的數量降成 0。在此期間，不會有任何 Prysm 程式能夠執行，我們也就能趁機執行腳本復原新版本帶來的 schema 變動，然後再恢復 pod 的數量，最後再回溯版本。以下是範例步驟及指令：</p><ol><li><p>在還原版本前，用以下指令先把 pod 的數量降成 0</p><p>只調整 beacon：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl scale deployments/beacon -nprysm --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</code></pre></div><p>如果 schema 變動只影響 validator，我們可以只調整 validator 用戶端：</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl scale deployments/validator-client-1 -nprysm --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</code></pre></div></li><li><p>確認所有 pod 都已停止</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl get pod -nprysm -w
</code></pre></div></li><li><p>執行腳本復原 schema 變動</p></li><li><p>回溯到版本 4</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s helm3 rollback eth2xk8s <span style=color:#ae81ff>4</span> -nprysm
</code></pre></div></li><li><p>恢復 beacon 及 validator 用戶端 pod 的數量</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl scale deployments/beacon -nprysm --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
microk8s kubectl scale deployments/validator-client-1 -nprysm --replicas<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</code></pre></div></li><li><p>確認所有 pod 都恢復執行</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>microk8s kubectl get pod -nprysm -w
</code></pre></div></li></ol></div><div class=post_footer></div></div><div class=doc_comments></div></div></div></div><div class=article-toc style=display:none><h3>內容</h3><nav id=TableOfContents><ul><li><a href=#為什麼使用-kubernetes-作-staking>為什麼使用 Kubernetes 作 staking？</a></li><li><a href=#感謝>感謝</a></li><li><a href=#使用工具>使用工具</a></li><li><a href=#本文目標>本文目標</a></li><li><a href=#非本文目標>非本文目標</a></li><li><a href=#免責聲明>免責聲明</a></li><li><a href=#系統需求>系統需求</a></li><li><a href=#網路需求>網路需求</a></li><li><a href=#事前準備>事前準備</a></li><li><a href=#設定步驟>設定步驟</a><ul><li><a href=#概要>概要</a></li><li><a href=#安裝系統更新>安裝系統更新</a></li><li><a href=#同步系統時間>同步系統時間</a></li><li><a href=#設定防火牆>設定防火牆</a></li><li><a href=#安裝-microk8s>安裝 MicroK8s</a></li><li><a href=#建立叢集>建立叢集</a></li><li><a href=#安裝和設定-nfs>安裝和設定 NFS</a></li><li><a href=#準備-validator-錢包>準備 Validator 錢包</a></li><li><a href=#改變資料目錄擁有者>改變資料目錄擁有者</a></li><li><a href=#準備-helm-chart>準備 Helm Chart</a></li><li><a href=#使用-helm-chart-安裝-prysm>使用 Helm Chart 安裝 Prysm</a></li><li><a href=#檢查用戶端狀態>檢查用戶端狀態</a></li><li><a href=#使用-helm-chart-更新-prysm-版本>使用 Helm Chart 更新 Prysm 版本</a></li><li><a href=#使用-helm-回溯版本>使用 Helm 回溯版本</a></li></ul></li><li><a href=#結論>結論</a></li><li><a href=#有任何建議或是疑問嗎>有任何建議或是疑問嗎？</a></li><li><a href=#附錄>附錄</a><ul><li><a href=#檢查-cpu-及記憶體用量>檢查 CPU 及記憶體用量</a></li><li><a href=#解除安裝-helm-chart>解除安裝 Helm Chart</a></li><li><a href=#使用-helm-回溯版本如果資料庫-schema-有更動>使用 Helm 回溯版本（如果資料庫 Schema 有更動）</a></li></ul></li></ul></nav></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.slim.min.js integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin=anonymous></script><script>(function(){var a=$('#TableOfContents'),b;if(a.length>0){b=$(window);function c(){var e=b.scrollTop(),f=$('.post_content h1, .post_content h2, .post_content h3, .post_content h4, .post_content h5, .post_content h6'),c="",d;if(f.each(function(b,a){a=$(a),a.offset().top-10<=e&&(c=a.attr('id'))}),d=a.find('a.active'),d.length==1&&d.eq(0).attr('href')=='#'+c)return!0;d.each(function(b,a){$(a).removeClass('active').siblings('ul').hide()}),a.find('a[href="#'+c+'"]').parentsUntil('#TableOfContents').each(function(b,a){$(a).children('a').addClass('active').siblings('ul').show()})}b.on('scroll',c),$(document).ready(function(){a.find('a').parent('li').find('ul').hide(),c(),document.getElementsByClassName('article-toc')[0].style.display=''})}})()</script><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://github.com/lumostone/lumostone.github.io>Source code hosted on Github.</a></div><div class=footer_slogan><span></span></div></footer><script src=https://lumostone.com/js/jquery-3.5.1.min.js></script><link href=https://lumostone.com/css/fancybox.min.css rel=stylesheet><script src=https://lumostone.com/js/fancybox.min.js></script><script src=https://lumostone.com/js/zozo.js></script></body></html>